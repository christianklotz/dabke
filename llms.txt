# dabke

> Scheduling library powered by constraint programming (CP-SAT)

---

## Schedule Definition

### `defineSchedule`

Define a complete schedule configuration.

```typescript
import {
  defineSchedule, t, time, cover, shift,
  maxHoursPerWeek, minRestBetweenShifts, timeOff,
  weekdays, weekend,
} from "dabke";

export default defineSchedule({
  roleIds: ["waiter", "runner", "manager"],
  skillIds: ["senior"],

  times: {
    lunch: time({ startTime: t(12), endTime: t(15) }),
    dinner: time(
      { startTime: t(17), endTime: t(21) },
      { startTime: t(18), endTime: t(22), dayOfWeek: weekend },
    ),
  },

  coverage: [
    cover("lunch", "waiter", 2),
    cover("dinner", "waiter", 4, { dayOfWeek: weekdays }),
    cover("dinner", "waiter", 6, { dayOfWeek: weekend }),
  ],

  shiftPatterns: [
    shift("morning", t(11, 30), t(15)),
    shift("evening", t(17), t(22)),
  ],

  rules: [
    maxHoursPerWeek(48),
    minRestBetweenShifts(10),
    timeOff({ appliesTo: "alice", dayOfWeek: weekend }),
  ],
});
```

**Parameters:**
- `config: ScheduleConfig<R, S, T>` — Schedule configuration object with:
- `roleIds` (required): declared role names
- `skillIds` (optional): declared skill names
- `times` (required): named semantic time periods (see `time`)
- `coverage` (required): staffing requirements (see `cover`)
- `shiftPatterns` (required): available shifts (see `shift`)
- `rules` (optional): constraints and preferences (see rule functions)
- `dayOfWeek` (optional): days the business operates (inclusion filter)
- `weekStartsOn` (optional): defaults to `"monday"`

**Returns:** `ScheduleDefinition`

---

## Time Periods

### `t`

Creates a `TimeOfDay` value.

Hours only
```ts
t(9)   // { hours: 9, minutes: 0 }
```

**Parameters:**
- `hours: number` — Hour component (0-23)
- `minutes: number` — Minute component (0-59)

**Returns:** `TimeOfDay`

### `weekdays`

Monday through Friday.

```typescript
readonly DayOfWeek[]
```

### `weekend`

Saturday and Sunday.

```typescript
readonly DayOfWeek[]
```

### `time`

Define a named semantic time period.

Each entry has `startTime`/`endTime` and optional `dayOfWeek` or `dates`
scoping. Entries without scoping are the default.

```typescript
times: {
  // Simple: same times every day
  lunch: time({ startTime: t(12), endTime: t(15) }),

  // Variants: different times on weekends
  dinner: time(
    { startTime: t(17), endTime: t(21) },
    { startTime: t(18), endTime: t(22), dayOfWeek: weekend },
  ),

  // Point-in-time window (keyholder at opening)
  opening: time({ startTime: t(8, 30), endTime: t(9) }),
}
```

---

## Coverage

### `cover`

Defines a staffing requirement for a semantic time period.

Entries for the same time and role **stack additively**.
For weekday vs weekend staffing, use mutually exclusive `dayOfWeek`
on both entries.

```typescript
coverage: [
  // 2 waiters during lunch
  cover("lunch", "waiter", 2),

  // 1 manager OR supervisor during dinner
  cover("dinner", ["manager", "supervisor"], 1),

  // 1 person with keyholder skill at opening
  cover("opening", "keyholder", 1),

  // 1 senior waiter (role + skill AND)
  cover("lunch", "waiter", 1, { skillIds: ["senior"] }),

  // Different counts by day (mutually exclusive dayOfWeek!)
  cover("lunch", "waiter", 2, { dayOfWeek: weekdays }),
  cover("lunch", "waiter", 3, { dayOfWeek: weekend }),
]
```

**Parameters:**
- `timeName: T` — Name of a declared semantic time
- `target: R | [R, ...R[]]` — Role name (string), array of role names (OR logic), or skill name
- `count: number` — Number of people needed
- `opts?: CoverageOptions` — Options: `skillIds` (AND filter), `dayOfWeek`, `dates`, `priority`

**Returns:** `CoverageEntry<T, R>`

---

## Shift Patterns

### `shift`

Define a shift pattern: a time slot available for employee assignment.

Each pattern repeats daily unless filtered by `dayOfWeek`.

```typescript
shiftPatterns: [
  shift("morning", t(11, 30), t(15)),
  shift("evening", t(17), t(22)),

  // Role-restricted shift
  shift("kitchen", t(6), t(14), { roleIds: ["chef", "prep_cook"] }),

  // Day-restricted shift
  shift("saturday_short", t(9), t(14), { dayOfWeek: ["saturday"] }),

  // Location-specific shift
  shift("terrace_lunch", t(12), t(16), { locationId: "terrace" }),
]
```

---

## Rules

### `RuleOptions`

Scoping options shared by most rule functions.

Default priority is `MANDATORY`. Use `appliesTo` to scope to a
role, skill, or member ID. Use time scoping options (`dayOfWeek`,
`dateRange`, `dates`) to limit when the rule applies.
Not all rules support all scoping options. Entity-only rules
(e.g., `maxConsecutiveDays`) ignore time scoping.

**Properties:**
- `appliesTo?: string | string[]` — Who this rule applies to (role name, skill name, or member ID).
- `dayOfWeek?: readonly DayOfWeek[]` — Restrict to specific days of the week.
- `dateRange?: { start: string; end: string }` — Restrict to a date range.
- `dates?: string[]` — Restrict to specific dates (YYYY-MM-DD).
- `recurringPeriods?: [RecurringPeriod, ...RecurringPeriod[]]` — Restrict to recurring calendar periods.
- `priority?: Priority` — Defaults to `"MANDATORY"`.

### `maxHoursPerDay`

Limits hours per day.

```typescript
maxHoursPerDay(10)
maxHoursPerDay(4, { appliesTo: "student", dayOfWeek: weekdays })
```

### `maxHoursPerWeek`

Limits hours per scheduling week.

```typescript
maxHoursPerWeek(48)
maxHoursPerWeek(20, { appliesTo: "student" })
```

### `minHoursPerDay`

Minimum hours when assigned on a day.

```typescript
minHoursPerDay(4)
```

### `minHoursPerWeek`

Minimum hours per scheduling week.

```typescript
minHoursPerWeek(20, { priority: "HIGH" })
```

### `maxShiftsPerDay`

Maximum distinct shifts per day.

```typescript
maxShiftsPerDay(1)
maxShiftsPerDay(2, { appliesTo: "student", dayOfWeek: weekend })
```

### `maxConsecutiveDays`

Maximum consecutive working days.

```typescript
maxConsecutiveDays(5)
```

### `minConsecutiveDays`

Once working, continue for at least this many consecutive days.

```typescript
minConsecutiveDays(2, { priority: "HIGH" })
```

### `minRestBetweenShifts`

Minimum rest hours between shifts.

```typescript
minRestBetweenShifts(10)
```

### `preference`

Prefer (`"high"`) or avoid (`"low"`) assigning. Requires `appliesTo`.

```typescript
preference("high", { appliesTo: "waiter" })
preference("low", { appliesTo: "student", dayOfWeek: weekdays })
```

### `preferLocation`

Prefer assigning to shifts at a specific location. Requires `appliesTo`.

```typescript
preferLocation("terrace", { appliesTo: "alice" })
```

### `minimizeCost`

Tells the solver to minimize total labor cost.

Without this rule, cost modifiers only affect post-solve calculation.
When present, the solver actively prefers cheaper assignments.

For hourly members, penalizes each assignment proportionally to cost.
For salaried members, adds a fixed weekly salary cost when they have
any assignment that week (zero marginal cost up to contracted hours).

Cost modifiers adjust the calculation:
- `dayMultiplier(factor, opts?)` - multiply base rate on specific days
- `daySurcharge(amount, opts?)` - flat extra per hour on specific days
- `timeSurcharge(amount, window, opts?)` - flat extra per hour during a time window
- `overtimeMultiplier({ after, factor }, opts?)` - weekly overtime multiplier
- `overtimeSurcharge({ after, amount }, opts?)` - weekly overtime surcharge
- `dailyOvertimeMultiplier({ after, factor }, opts?)` - daily overtime multiplier
- `dailyOvertimeSurcharge({ after, amount }, opts?)` - daily overtime surcharge
- `tieredOvertimeMultiplier(tiers, opts?)` - multiple overtime thresholds

```ts
minimizeCost()
```

### `timeOff`

Block assignments during specified periods.
Requires at least one time scope (`dayOfWeek`, `dateRange`, `dates`, or `from`/`until`).

```typescript
// Full days off
timeOff({ appliesTo: "alice", dateRange: { start: "2024-02-01", end: "2024-02-05" } })

// Every weekend off
timeOff({ appliesTo: "mauro", dayOfWeek: weekend })

// Wednesday afternoons off
timeOff({ appliesTo: "student", dayOfWeek: ["wednesday"], from: t(14) })
```

### `assignTogether`

Members work the same shifts on days they are both assigned.

```typescript
assignTogether(["alice", "bob"])
assignTogether(["alice", "bob", "charlie"], { priority: "HIGH" })
```

---

## Supporting Types

### `DayOfWeek`

Day of the week identifier.

```typescript
"monday" | "tuesday" | "wednesday" | "thursday" | "friday" | "saturday" | "sunday"
```

### `TimeOfDay`

Time of day (24-hour format).

**Properties:**
- `hours: number`
- `minutes: number`

### `Priority`

How strictly the solver enforces a rule.

- `"LOW"`, `"MEDIUM"`, `"HIGH"`: soft constraints with increasing penalty for violations
- `"MANDATORY"`: hard constraint; the solver will not produce a solution that violates it

```typescript
"LOW" | "MEDIUM" | "HIGH" | "MANDATORY"
```

