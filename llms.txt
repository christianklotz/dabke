# dabke

> Scheduling library powered by constraint programming (CP-SAT)

---

## Semantic Times & Coverage

### defineSemanticTimes
Define semantic times with type-safe names.

Returns a context object that provides:
- Type-safe coverage() function that only accepts defined semantic time names
- resolve() function to expand semantic times to concrete requirements

**Example:**
Basic usage
```typescript
const times = defineSemanticTimes({
opening: { startTime: { hours: 6 }, endTime: { hours: 8 } },
lunch: { startTime: { hours: 11, minutes: 30 }, endTime: { hours: 14 } },
closing: { startTime: { hours: 21 }, endTime: { hours: 23 } },
});

const coverage = times.coverage([
{ semanticTime: "lunch", roleId: "server", targetCount: 3 },
{ semanticTime: "opening", roleId: "keyholder", targetCount: 1, priority: "MANDATORY" },
// Type error: "dinner" is not a defined semantic time
// { semanticTime: "dinner", roleId: "server", targetCount: 2 },
]);
```

**Example:**
Variants for different days
```typescript
const times = defineSemanticTimes({
lunch: [
{ startTime: { hours: 11, minutes: 30 }, endTime: { hours: 14 }, dayOfWeek: ["monday", "tuesday", "wednesday", "thursday", "friday"] },
{ startTime: { hours: 12 }, endTime: { hours: 15 }, dayOfWeek: ["saturday", "sunday"] },
],
});
```

**Example:**
Mixed semantic and concrete coverage
```typescript
const coverage = times.coverage([
{ semanticTime: "lunch", roleId: "server", targetCount: 3 },
// One-off party - concrete time
{ day: "2026-01-14", startTime: { hours: 15 }, endTime: { hours: 20 }, roleId: "server", targetCount: 5 },
]);
```

**Parameters:**
- `defs: T`

**Returns:** `SemanticTimeContext<keyof T & string>`


### SemanticTimeDef
Base definition for a semantic time period.

**Properties:**
- `startTime: TimeOfDay` - When this time period starts.
- `endTime: TimeOfDay` - When this time period ends.


### SemanticTimeVariant
Variant of a semantic time that applies to specific days or dates.

**Properties:**
- `dayOfWeek?: DayOfWeek[] | undefined` - Apply this variant only on these days of the week
- `dates?: string[] | undefined` - Apply this variant only on these specific dates (YYYY-MM-DD)


### SemanticTimeEntry
A semantic time can be a simple definition (applies every day)
or an array of variants with different times for different days/dates.

```typescript
SemanticTimeDef | SemanticTimeVariant[]
```


### SemanticTimeContext
Result of defineSemanticTimes - provides type-safe coverage function.

**Properties:**
- `defs: { [P in S]: SemanticTimeEntry; }` - The semantic time definitions
- `coverage: (reqs: MixedCoverageRequirement<S>[]) => MixedCoverageRequirement<S>[]` - Create coverage requirements with type-safe semantic time names.
Accepts both semantic references and concrete one-off requirements.
- `resolve: (reqs: MixedCoverageRequirement<S>[], days: string[]) => CoverageRequirement[]` - Resolve all coverage requirements to concrete CoverageRequirement[]
for the given days in the scheduling horizon.


### SemanticCoverageRequirement
Coverage requirement that references a semantic time by name.
Type-safe: S is constrained to known semantic time names.

This is a discriminated union enforcing at compile time that at least
one of `roleIds` or `skillIds` must be provided.

**Fields:**
- `semanticTime` (required) — name of a defined semantic time
- `targetCount` (required) — how many people are needed
- `roleIds` — roles that satisfy this (OR logic); at least one of `roleIds`/`skillIds` required
- `skillIds` — skills required (AND logic); at least one of `roleIds`/`skillIds` required
- `dayOfWeek` — scope to specific days of the week (e.g. `["monday", "tuesday"]`)
- `dates` — scope to specific dates (`"YYYY-MM-DD"` strings)
- `priority` — `"MANDATORY"` | `"HIGH"` | `"MEDIUM"` | `"LOW"`

**IMPORTANT: Coverage entries for the same semantic time STACK additively.**
For weekday vs weekend staffing, use mutually exclusive `dayOfWeek` on BOTH entries:

**Example:**
Weekday vs weekend (mutually exclusive dayOfWeek)
```typescript
{ semanticTime: "lunch", roleIds: ["waiter"], targetCount: 2,
dayOfWeek: ["monday", "tuesday", "wednesday", "thursday", "friday"] },
{ semanticTime: "lunch", roleIds: ["waiter"], targetCount: 3,
dayOfWeek: ["saturday", "sunday"] },
```

**Example:**
Skill-based coverage (any role with the skill)
```typescript
{ semanticTime: "opening", skillIds: ["keyholder"], targetCount: 1 },
```

```typescript
RoleBasedSemanticCoverageRequirement<S> | SkillBasedSemanticCoverageRequirement<S>
```


### ConcreteCoverageRequirement
Concrete coverage requirement with explicit day and times.
Used for one-off requirements that don't fit a semantic time.

This is a discriminated union enforcing at compile time that at least
one of `roleIds` or `skillIds` must be provided.

```typescript
RoleBasedConcreteCoverageRequirement | SkillBasedConcreteCoverageRequirement
```


### MixedCoverageRequirement
Union type for coverage - either semantic (type-safe) or concrete.

```typescript
ConcreteCoverageRequirement | SemanticCoverageRequirement<S>
```


---

## Shift Patterns

### ShiftPattern
A shift pattern defines WHEN people can work: the time slots available for assignment.

Shift patterns are templates that repeat across all scheduling days. The solver assigns
team members to these patterns based on coverage requirements and constraints.

**Example:**
// Simple venue: one shift type, anyone can work it
const patterns: ShiftPattern[] = [
  { id: "day", startTime: { hours: 9 }, endTime: { hours: 17 } }
];

**Example:**
// Restaurant: different shifts for different roles
const patterns: ShiftPattern[] = [
  { id: "kitchen_morning", startTime: { hours: 6 }, endTime: { hours: 14 }, roleIds: ["chef", "prep_cook"] },
  { id: "floor_lunch", startTime: { hours: 11 }, endTime: { hours: 15 }, roleIds: ["waiter", "host"] },
];

**Properties:**
- `id: string` - Unique identifier for this shift pattern.
Used in assignments and rule configurations.
- `roleIds?: [string, ...string[]] | undefined` - Restricts who can be assigned to this shift based on their roles.

- If omitted: anyone can work this shift
- If provided: only team members whose roleIds overlap with this list can be assigned

Most venues have the same shifts for everyone and don't need this.
Use it when different roles have different schedules (e.g., kitchen staff starts
earlier than floor staff).
- `dayOfWeek?: DayOfWeek[] | undefined` - Restricts which days of the week this shift pattern can be used.

- If omitted: shift can be used on any day
- If provided: shift can only be assigned on the specified days

**Example:**
```typescript
// Saturday-only short shift
{ id: "saturday_shift", startTime: t(9), endTime: t(14), dayOfWeek: ["saturday"] }

// Weekday-only full shift
{ id: "full_shift", startTime: t(9), endTime: t(18), dayOfWeek: ["monday", "tuesday", "wednesday", "thursday", "friday"] }
```
- `locationId?: string | undefined` - Physical location where this shift takes place.
Used for multi-location scheduling and location-based constraints.
- `startTime: TimeOfDay` - When the shift starts (e.g., `{ hours: 9, minutes: 0 }` for 9:00 AM)
- `endTime: TimeOfDay` - When the shift ends (e.g., `{ hours: 17, minutes: 30 }` for 5:30 PM)


---

## Rules

### CpsatRuleConfigEntry
A named rule configuration entry.

Flat discriminated union: `name` is the discriminant and all config fields
(including scope fields like `employeeIds`, `dayOfWeek`, etc.) sit at the
same level. This eliminates the `{ name, config: { ... } }` nesting that
invited misplacement of scope fields.

**Example:**
```ts
const rules: CpsatRuleConfigEntry[] = [
  { name: "max-hours-week", hours: 40, priority: "MANDATORY" },
  { name: "time-off", employeeIds: ["alice"], dayOfWeek: ["monday"], priority: "MANDATORY" },
];
```

```typescript
[Complex type - see source code]
```


### Built-In Rules

Each rule is a flat object in the `ruleConfigs` array with `name` as the discriminant.

**Scoping fields** available on most rules:
- Entity (at most one): `employeeIds`, `roleIds`, `skillIds`
- Time (at most one): `dateRange`, `specificDates`, `dayOfWeek`, `recurringPeriods`

#### assign-together
Encourages or enforces that team members in the group work the same shift patterns on a day.
For each pair of team members in the group, ensures they are assigned to the same shifts.

**Example:**
```ts
{ name: "assign-together",
  groupEmployeeIds: ["alice", "bob", "charlie"],
  priority: "HIGH",
}
```

#### employee-assignment-priority
Adds objective weight to prefer or avoid assigning team members.

**Example:**
Prefer specific team members
```ts
{ name: "employee-assignment-priority",
employeeIds: ["alice", "bob"],
preference: "high",
}
```

**Example:**
Avoid assigning students on weekdays
```ts
{ name: "employee-assignment-priority",
roleIds: ["student"],
dayOfWeek: ["monday", "tuesday", "wednesday", "thursday", "friday"],
preference: "low",
}
```

#### location-preference
Prefers assigning a person to shift patterns matching a specific location.

**Example:**
```ts
{ name: "location-preference",
  locationId: "terrace",
  priority: "HIGH",
  employeeIds: ["alice"],
}
```

#### max-consecutive-days
Limits how many consecutive days a person can be assigned.

**Example:**
```ts
{ name: "max-consecutive-days", days: 5, priority: "MANDATORY" }
```

#### max-hours-day
Limits how many hours a person can work in a single day.

**Example:**
Limit everyone to 8 hours per day
```ts
{ name: "max-hours-day",
hours: 8,
priority: "MANDATORY",
}
```

**Example:**
Students limited to 4 hours on weekdays during term
```ts
{ name: "max-hours-day",
roleIds: ["student"],
hours: 4,
dayOfWeek: ["monday", "tuesday", "wednesday", "thursday", "friday"],
priority: "MANDATORY",
}
```

#### max-hours-week
Caps total hours a person can work within each scheduling week.

**Example:**
Limit everyone to 40 hours per week
```ts
{ name: "max-hours-week", hours: 40, priority: "HIGH" }
```

**Example:**
Students limited to 20 hours during term time
```ts
{ name: "max-hours-week",
roleIds: ["student"],
hours: 20,
recurringPeriods: [
{ name: "fall-term", startMonth: 9, startDay: 1, endMonth: 12, endDay: 15 },
],
priority: "MANDATORY",
}
```

#### max-shifts-day
Limits how many shifts a person can work in a single day.

Controls the maximum number of distinct shift assignments per day,
regardless of shift duration. For limiting total hours worked, use `max-hours-day`.

**Example:**
Limit to one shift per day
```ts
{ name: "max-shifts-day",
shifts: 1,
priority: "MANDATORY",
}
```

**Example:**
Students can work 2 shifts on weekends only
```ts
{ name: "max-shifts-day",
roleIds: ["student"],
shifts: 2,
dayOfWeek: ["saturday", "sunday"],
priority: "MANDATORY",
}
```

#### min-consecutive-days
Requires that once a person starts working, they continue for a minimum
number of consecutive days.

**Example:**
```ts
{ name: "min-consecutive-days", days: 3, priority: "MANDATORY" }
```

#### min-hours-day
Ensures a person works at least a minimum number of hours per day.

**Example:**
```ts
{ name: "min-hours-day", hours: 6, priority: "MANDATORY" }
```

#### min-hours-week
Enforces a minimum total number of hours per scheduling week.

**Example:**
```ts
{ name: "min-hours-week", hours: 30, priority: "HIGH" }
```

#### min-rest-between-shifts
Enforces a minimum rest period between any two shifts a person works.

**Example:**
```ts
{ name: "min-rest-between-shifts", hours: 10, priority: "MANDATORY" }
```

#### time-off
Blocks or penalizes assignments during specified time periods.

Supports entity scoping (people, roles, skills) and time scoping
(date ranges, specific dates, days of week, recurring periods).
Optionally supports partial-day time-off with startTime/endTime.

**Example:**
Full day vacation
```ts
{ name: "time-off",
employeeIds: ["alice"],
dateRange: { start: "2024-02-01", end: "2024-02-05" },
priority: "MANDATORY",
}
```

**Example:**
Every Wednesday afternoon off for students
```ts
{ name: "time-off",
roleIds: ["student"],
dayOfWeek: ["wednesday"],
startTime: { hours: 14, minutes: 0 },
endTime: { hours: 23, minutes: 59 },
priority: "MANDATORY",
}
```

**Example:**
Specific date, partial day
```ts
{ name: "time-off",
employeeIds: ["bob"],
specificDates: ["2024-03-15"],
startTime: { hours: 16, minutes: 0 },
endTime: { hours: 23, minutes: 59 },
priority: "MANDATORY",
}
```

---

## Supporting Types

### TimeOfDay
Time of day representation (hours and minutes, with optional seconds/nanos).

Used for defining shift start/end times and semantic time boundaries.
Hours are in 24-hour format (0-23).

**Example:**
```typescript
const morningStart: TimeOfDay = {
  hours: 9,
  minutes: 0
};

const afternoonEnd: TimeOfDay = {
  hours: 17,
  minutes: 30
};
```

**Properties:**
- `hours: number`
- `minutes: number`
- `seconds?: number | undefined`
- `nanos?: number | undefined`


### DayOfWeek
Day of the week identifier.

```typescript
"monday" | "tuesday" | "wednesday" | "thursday" | "friday" | "saturday" | "sunday"
```


### SchedulingPeriod
Defines a scheduling period as a date range with optional filters.

The `dateRange` specifies the overall scheduling window. Use `dayOfWeek`
and/or `dates` to narrow which days within the range are included.
Filters compose: a day must pass all specified filters to be included.

**Example:**
All days in a week
```typescript
const period: SchedulingPeriod = {
dateRange: { start: '2025-02-03', end: '2025-02-09' },
};
```

**Example:**
Only specific days of the week (restaurant closed Mon/Tue)
```typescript
const period: SchedulingPeriod = {
dateRange: { start: '2025-02-03', end: '2025-02-09' },
dayOfWeek: ['wednesday', 'thursday', 'friday', 'saturday', 'sunday'],
};
```

**Example:**
Only specific dates within the range
```typescript
const period: SchedulingPeriod = {
dateRange: { start: '2025-02-03', end: '2025-02-09' },
dates: ['2025-02-05', '2025-02-07'],
};
```

**Properties:**
- `dateRange: { start: string; end: string; }` - The overall scheduling window (start and end are inclusive).
Dates should be in YYYY-MM-DD format.
- `dayOfWeek?: DayOfWeek[] | undefined` - Include only these days of the week.
If omitted, all days of the week are included.
- `dates?: string[] | undefined` - Include only these specific dates (YYYY-MM-DD) within the range.
If omitted, all dates in the range are included (subject to dayOfWeek filter).


### SchedulingEmployee
A team member available for scheduling.

Employees are assigned to shift patterns by the solver based on
coverage requirements, rules, and constraints.

**Properties:**
- `id: string` - Unique identifier for this employee. Must not contain colons.
- `roleIds: string[]` - Roles this employee can fill (e.g. "waiter", "chef").
- `skillIds?: string[] | undefined` - Skills this employee has (e.g. "senior", "trainer").


### Priority
How strictly the solver enforces a rule.

- `"LOW"`, `"MEDIUM"`, `"HIGH"`: soft constraints with increasing penalty for violations
- `"MANDATORY"`: hard constraint; the solver will not produce a solution that violates it

```typescript
"LOW" | "MEDIUM" | "HIGH" | "MANDATORY"
```


