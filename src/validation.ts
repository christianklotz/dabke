/**
 * Validation utilities for scheduling configuration.
 *
 * These functions help catch configuration errors early, before the ModelBuilder
 * attempts to compile the scheduling problem. This is especially useful when
 * configuration is generated by an LLM, which may hallucinate role or skill names.
 */

import type { CoverageRequirement, SchedulingEmployee } from "./cpsat/types.js";

/**
 * Result of coverage role validation.
 */
export interface CoverageValidationResult {
  valid: boolean;
  /** Role IDs used in coverage that don't match any team member */
  unknownRoles: string[];
  /** Role IDs used in coverage that match team members */
  knownRoles: string[];
}

/**
 * Validates that all roleIds used in coverage requirements match the team.
 *
 * This catches a common LLM error where the model generates coverage requirements
 * using role names that don't match any team member's roleIds. Without this validation,
 * such mismatches would result in valid but semantically wrong schedules (e.g.,
 * coverage requirements that no one can satisfy).
 *
 * @example
 * ```typescript
 * const employees = [
 *   { id: "alice", roleIds: ["cashier"] },
 *   { id: "bob", roleIds: ["stocker"] },
 * ];
 *
 * const coverage = [
 *   { roleId: "cashier", targetCount: 1, ... },  // OK
 *   { roleId: "worker", targetCount: 1, ... },   // Unknown role!
 * ];
 *
 * const result = validateCoverageRoles(coverage, employees);
 * // result.valid = false
 * // result.unknownRoles = ["worker"]
 * // result.knownRoles = ["cashier"]
 * ```
 */
export function validateCoverageRoles(
  coverage: CoverageRequirement[],
  employees: SchedulingEmployee[],
): CoverageValidationResult {
  const employeeRoles = new Set(employees.flatMap((e) => e.roleIds));
  const coverageRoles = new Set(coverage.flatMap((c) => c.roleIds ?? []));

  const unknownRoles: string[] = [];
  const knownRoles: string[] = [];

  for (const role of coverageRoles) {
    if (employeeRoles.has(role)) {
      knownRoles.push(role);
    } else {
      unknownRoles.push(role);
    }
  }

  return {
    valid: unknownRoles.length === 0,
    unknownRoles: unknownRoles.toSorted(),
    knownRoles: knownRoles.toSorted(),
  };
}

/**
 * Result of coverage skill validation.
 */
export interface SkillValidationResult {
  valid: boolean;
  /** Skill IDs used in coverage that don't match any team member */
  unknownSkills: string[];
  /** Skill IDs used in coverage that match team members */
  knownSkills: string[];
}

/**
 * Validates that all skillIds used in coverage requirements match the team.
 *
 * Similar to role validation, this catches LLM hallucinations where skill names
 * in coverage don't match any team member's skillIds.
 *
 * @example
 * ```typescript
 * const employees = [
 *   { id: "alice", roleIds: ["server"], skillIds: ["keyholder"] },
 *   { id: "bob", roleIds: ["server"] },
 * ];
 *
 * const coverage = [
 *   { skillIds: ["keyholder"], targetCount: 1, ... },  // OK
 *   { skillIds: ["manager"], targetCount: 1, ... },   // Unknown skill!
 * ];
 *
 * const result = validateCoverageSkills(coverage, employees);
 * // result.valid = false
 * // result.unknownSkills = ["manager"]
 * ```
 */
export function validateCoverageSkills(
  coverage: CoverageRequirement[],
  employees: SchedulingEmployee[],
): SkillValidationResult {
  const employeeSkills = new Set(employees.flatMap((e) => e.skillIds ?? []));
  const coverageSkills = new Set(coverage.flatMap((c) => c.skillIds ?? []));

  const unknownSkills: string[] = [];
  const knownSkills: string[] = [];

  for (const skill of coverageSkills) {
    if (employeeSkills.has(skill)) {
      knownSkills.push(skill);
    } else {
      unknownSkills.push(skill);
    }
  }

  return {
    valid: unknownSkills.length === 0,
    unknownSkills: unknownSkills.toSorted(),
    knownSkills: knownSkills.toSorted(),
  };
}

/**
 * Combined validation result for coverage requirements.
 */
export interface CoverageConfigValidationResult {
  valid: boolean;
  roles: CoverageValidationResult;
  skills: SkillValidationResult;
  /** Human-readable error messages */
  errors: string[];
}

/**
 * Validates coverage requirements against team roles and skills.
 *
 * This is the primary validation function to call before building a scheduling model.
 * It checks both roles and skills, returning a combined result with error messages.
 *
 * @example
 * ```typescript
 * const result = validateCoverageConfig(coverage, employees);
 * if (!result.valid) {
 *   throw new Error(result.errors.join("; "));
 * }
 * ```
 */
export function validateCoverageConfig(
  coverage: CoverageRequirement[],
  employees: SchedulingEmployee[],
): CoverageConfigValidationResult {
  const roles = validateCoverageRoles(coverage, employees);
  const skills = validateCoverageSkills(coverage, employees);

  const errors: string[] = [];

  if (!roles.valid) {
    const availableRoles = [...new Set(employees.flatMap((e) => e.roleIds))].toSorted();
    errors.push(
      `Coverage uses unknown roles: ${roles.unknownRoles.join(", ")}. ` +
        `Available roles: ${availableRoles.join(", ")}`,
    );
  }

  if (!skills.valid) {
    const availableSkills = [...new Set(employees.flatMap((e) => e.skillIds ?? []))].toSorted();
    errors.push(
      `Coverage uses unknown skills: ${skills.unknownSkills.join(", ")}. ` +
        `Available skills: ${availableSkills.length > 0 ? availableSkills.join(", ") : "(none)"}`,
    );
  }

  return {
    valid: roles.valid && skills.valid,
    roles,
    skills,
    errors,
  };
}
