// Auto-generated TypeScript export of llms.txt
// This file is automatically generated by generate-llmstxt.ts
// Do not edit manually - it will be overwritten

/**
 * LLM-friendly API documentation for dabke
 */
export const apiDocs =
  '# dabke\n\n> Scheduling library powered by constraint programming (CP-SAT)\n\n---\n\n## Semantic Times & Coverage\n\n### defineSemanticTimes\nDefine semantic times with type-safe names.\n\nReturns a context object that provides:\n- Type-safe coverage() function that only accepts defined semantic time names\n- resolve() function to expand semantic times to concrete requirements\n\n**Example:**\nBasic usage\n```typescript\nconst times = defineSemanticTimes({\nopening: { startTime: { hours: 6 }, endTime: { hours: 8 } },\nlunch: { startTime: { hours: 11, minutes: 30 }, endTime: { hours: 14 } },\nclosing: { startTime: { hours: 21 }, endTime: { hours: 23 } },\n});\n\nconst coverage = times.coverage([\n{ semanticTime: "lunch", roleId: "server", targetCount: 3 },\n{ semanticTime: "opening", roleId: "keyholder", targetCount: 1, priority: "MANDATORY" },\n// Type error: "dinner" is not a defined semantic time\n// { semanticTime: "dinner", roleId: "server", targetCount: 2 },\n]);\n```\n\n**Example:**\nVariants for different days\n```typescript\nconst times = defineSemanticTimes({\nlunch: [\n{ startTime: { hours: 11, minutes: 30 }, endTime: { hours: 14 }, dayOfWeek: ["monday", "tuesday", "wednesday", "thursday", "friday"] },\n{ startTime: { hours: 12 }, endTime: { hours: 15 }, dayOfWeek: ["saturday", "sunday"] },\n],\n});\n```\n\n**Example:**\nMixed semantic and concrete coverage\n```typescript\nconst coverage = times.coverage([\n{ semanticTime: "lunch", roleId: "server", targetCount: 3 },\n// One-off party - concrete time\n{ day: "2026-01-14", startTime: { hours: 15 }, endTime: { hours: 20 }, roleId: "server", targetCount: 5 },\n]);\n```\n\n**Parameters:**\n- `defs: T`\n\n**Returns:** `SemanticTimeContext<keyof T & string>`\n\n\n### SemanticTimeDef\nBase definition for a semantic time period.\n\n**Properties:**\n- `startTime: TimeOfDay` - When this time period starts.\n- `endTime: TimeOfDay` - When this time period ends.\n\n\n### SemanticTimeVariant\nVariant of a semantic time that applies to specific days or dates.\n\n**Properties:**\n- `dayOfWeek?: DayOfWeek[] | undefined` - Apply this variant only on these days of the week\n- `dates?: string[] | undefined` - Apply this variant only on these specific dates (YYYY-MM-DD)\n\n\n### SemanticTimeEntry\nA semantic time can be a simple definition (applies every day)\nor an array of variants with different times for different days/dates.\n\n```typescript\nSemanticTimeDef | SemanticTimeVariant[]\n```\n\n\n### SemanticTimeContext\nResult of defineSemanticTimes - provides type-safe coverage function.\n\n**Properties:**\n- `defs: { [P in S]: SemanticTimeEntry; }` - The semantic time definitions\n- `coverage: (reqs: MixedCoverageRequirement<S>[]) => MixedCoverageRequirement<S>[]` - Create coverage requirements with type-safe semantic time names.\nAccepts both semantic references and concrete one-off requirements.\n- `resolve: (reqs: MixedCoverageRequirement<S>[], days: string[]) => CoverageRequirement[]` - Resolve all coverage requirements to concrete CoverageRequirement[]\nfor the given days in the scheduling horizon.\n\n\n### SemanticCoverageRequirement\nCoverage requirement that references a semantic time by name.\nType-safe: S is constrained to known semantic time names.\n\nThis is a discriminated union enforcing at compile time that at least\none of `roles` or `skills` must be provided.\n\n**Fields:**\n- `semanticTime` (required) — name of a defined semantic time\n- `targetCount` (required) — how many people are needed\n- `roles` — roles that satisfy this (OR logic); at least one of `roles`/`skills` required\n- `skills` — skills required (AND logic); at least one of `roles`/`skills` required\n- `dayOfWeek` — scope to specific days of the week (e.g. `["monday", "tuesday"]`)\n- `dates` — scope to specific dates (`"YYYY-MM-DD"` strings)\n- `priority` — `"MANDATORY"` | `"HIGH"` | `"MEDIUM"` | `"LOW"`\n\n**IMPORTANT: Coverage entries for the same semantic time STACK additively.**\nFor weekday vs weekend staffing, use mutually exclusive `dayOfWeek` on BOTH entries:\n\n**Example:**\nWeekday vs weekend (mutually exclusive dayOfWeek)\n```typescript\n{ semanticTime: "lunch", roles: ["waiter"], targetCount: 2,\ndayOfWeek: ["monday", "tuesday", "wednesday", "thursday", "friday"] },\n{ semanticTime: "lunch", roles: ["waiter"], targetCount: 3,\ndayOfWeek: ["saturday", "sunday"] },\n```\n\n**Example:**\nSkill-based coverage (any role with the skill)\n```typescript\n{ semanticTime: "opening", skills: ["keyholder"], targetCount: 1 },\n```\n\n```typescript\nRoleBasedSemanticCoverageRequirement<S> | SkillBasedSemanticCoverageRequirement<S>\n```\n\n\n### ConcreteCoverageRequirement\nConcrete coverage requirement with explicit day and times.\nUsed for one-off requirements that don\'t fit a semantic time.\n\nThis is a discriminated union enforcing at compile time that at least\none of `roles` or `skills` must be provided.\n\n```typescript\nRoleBasedConcreteCoverageRequirement | SkillBasedConcreteCoverageRequirement\n```\n\n\n### MixedCoverageRequirement\nUnion type for coverage - either semantic (type-safe) or concrete.\n\n```typescript\nConcreteCoverageRequirement | SemanticCoverageRequirement<S>\n```\n\n\n---\n\n## Shift Patterns\n\n### ShiftPattern\nA shift pattern defines WHEN people can work: the time slots available for assignment.\n\nShift patterns are templates that repeat across all scheduling days. The solver assigns\nteam members to these patterns based on coverage requirements and constraints.\n\n**Example:**\n// Simple venue: one shift type, anyone can work it\nconst patterns: ShiftPattern[] = [\n  { id: "day", startTime: { hours: 9 }, endTime: { hours: 17 } }\n];\n\n**Example:**\n// Restaurant: different shifts for different roles\nconst patterns: ShiftPattern[] = [\n  { id: "kitchen_morning", startTime: { hours: 6 }, endTime: { hours: 14 }, roles: ["chef", "prep_cook"] },\n  { id: "floor_lunch", startTime: { hours: 11 }, endTime: { hours: 15 }, roles: ["waiter", "host"] },\n];\n\n**Properties:**\n- `id: string` - Unique identifier for this shift pattern.\nUsed in assignments and rule configurations.\n- `roles?: [string, ...string[]] | undefined` - Restricts who can be assigned to this shift based on their roles.\n\n- If omitted: anyone can work this shift\n- If provided: only team members whose roles overlap with this list can be assigned\n\nMost venues have the same shifts for everyone and don\'t need this.\nUse it when different roles have different schedules (e.g., kitchen staff starts\nearlier than floor staff).\n- `dayOfWeek?: DayOfWeek[] | undefined` - Restricts which days of the week this shift pattern can be used.\n\n- If omitted: shift can be used on any day\n- If provided: shift can only be assigned on the specified days\n\n**Example:**\n```typescript\n// Saturday-only short shift\n{ id: "saturday_shift", startTime: t(9), endTime: t(14), dayOfWeek: ["saturday"] }\n\n// Weekday-only full shift\n{ id: "full_shift", startTime: t(9), endTime: t(18), dayOfWeek: ["monday", "tuesday", "wednesday", "thursday", "friday"] }\n```\n- `locationId?: string | undefined` - Physical location where this shift takes place.\nUsed for multi-location scheduling and location-based constraints.\n- `startTime: TimeOfDay` - When the shift starts (e.g., `{ hours: 9, minutes: 0 }` for 9:00 AM)\n- `endTime: TimeOfDay` - When the shift ends (e.g., `{ hours: 17, minutes: 30 }` for 5:30 PM)\n\n\n---\n\n## Rules\n\n### CpsatRuleConfigEntry\nA named rule configuration entry.\n\nFlat discriminated union: `name` is the discriminant and all config fields\n(including scope fields like `memberIds`, `dayOfWeek`, etc.) sit at the\nsame level. This eliminates the `{ name, config: { ... } }` nesting that\ninvited misplacement of scope fields.\n\n**Example:**\n```ts\nconst rules: CpsatRuleConfigEntry[] = [\n  { name: "max-hours-week", hours: 40, priority: "MANDATORY" },\n  { name: "time-off", memberIds: ["alice"], dayOfWeek: ["monday"], priority: "MANDATORY" },\n];\n```\n\n```typescript\n[Complex type - see source code]\n```\n\n\n### Built-In Rules\n\nEach rule is a flat object in the `ruleConfigs` array with `name` as the discriminant.\n\n**Scoping fields** available on most rules:\n- Entity (at most one): `memberIds`, `roleIds`, `skillIds`\n- Time (at most one): `dateRange`, `specificDates`, `dayOfWeek`, `recurringPeriods`\n\n#### assign-together\nEncourages or enforces that team members in the group work the same shift patterns on a day.\nFor each pair of team members in the group, ensures they are assigned to the same shifts.\n\n**Example:**\n```ts\n{ name: "assign-together",\n  groupMemberIds: ["alice", "bob", "charlie"],\n  priority: "HIGH",\n}\n```\n\n#### assignment-priority\nAdds objective weight to prefer or avoid assigning team members.\n\n**Example:**\nPrefer specific team members\n```ts\n{ name: "assignment-priority",\nmemberIds: ["alice", "bob"],\npreference: "high",\n}\n```\n\n**Example:**\nAvoid assigning students on weekdays\n```ts\n{ name: "assignment-priority",\nroleIds: ["student"],\ndayOfWeek: ["monday", "tuesday", "wednesday", "thursday", "friday"],\npreference: "low",\n}\n```\n\n#### day-cost-multiplier\nCreates a day-based rate multiplier rule.\n\nMultiplies the base rate for assignments on matching days. The extra cost\nabove 1x is added as a penalty term (the base 1x is handled by `minimizeCost()`).\n\nWhen `minimizeCost()` is not present, no solver terms are emitted,\nbut the `cost()` method still contributes to post-solve calculation.\n\n#### day-cost-surcharge\nCreates a day-based flat surcharge rule.\n\nAdds a flat extra amount per hour for assignments on matching days,\nindependent of the member\'s base rate.\n\nWhen `minimizeCost()` is not present, no solver terms are emitted,\nbut the `cost()` method still contributes to post-solve calculation.\n\n#### location-preference\nPrefers assigning a person to shift patterns matching a specific location.\n\n**Example:**\n```ts\n{ name: "location-preference",\n  locationId: "terrace",\n  priority: "HIGH",\n  memberIds: ["alice"],\n}\n```\n\n#### max-consecutive-days\nLimits how many consecutive days a person can be assigned.\n\n**Example:**\n```ts\n{ name: "max-consecutive-days", days: 5, priority: "MANDATORY" }\n```\n\n#### max-hours-day\nLimits how many hours a person can work in a single day.\n\n**Example:**\nLimit everyone to 8 hours per day\n```ts\n{ name: "max-hours-day",\nhours: 8,\npriority: "MANDATORY",\n}\n```\n\n**Example:**\nStudents limited to 4 hours on weekdays during term\n```ts\n{ name: "max-hours-day",\nroleIds: ["student"],\nhours: 4,\ndayOfWeek: ["monday", "tuesday", "wednesday", "thursday", "friday"],\npriority: "MANDATORY",\n}\n```\n\n#### max-hours-week\nCaps total hours a person can work within each scheduling week.\n\n**Example:**\nLimit everyone to 40 hours per week\n```ts\n{ name: "max-hours-week", hours: 40, priority: "HIGH" }\n```\n\n**Example:**\nStudents limited to 20 hours during term time\n```ts\n{ name: "max-hours-week",\nroleIds: ["student"],\nhours: 20,\nrecurringPeriods: [\n{ name: "fall-term", startMonth: 9, startDay: 1, endMonth: 12, endDay: 15 },\n],\npriority: "MANDATORY",\n}\n```\n\n#### max-shifts-day\nLimits how many shifts a person can work in a single day.\n\nControls the maximum number of distinct shift assignments per day,\nregardless of shift duration. For limiting total hours worked, use `max-hours-day`.\n\n**Example:**\nLimit to one shift per day\n```ts\n{ name: "max-shifts-day",\nshifts: 1,\npriority: "MANDATORY",\n}\n```\n\n**Example:**\nStudents can work 2 shifts on weekends only\n```ts\n{ name: "max-shifts-day",\nroleIds: ["student"],\nshifts: 2,\ndayOfWeek: ["saturday", "sunday"],\npriority: "MANDATORY",\n}\n```\n\n#### min-consecutive-days\nRequires that once a person starts working, they continue for a minimum\nnumber of consecutive days.\n\n**Example:**\n```ts\n{ name: "min-consecutive-days", days: 3, priority: "MANDATORY" }\n```\n\n#### min-hours-day\nEnsures a person works at least a minimum number of hours per day.\n\n**Example:**\n```ts\n{ name: "min-hours-day", hours: 6, priority: "MANDATORY" }\n```\n\n#### min-hours-week\nEnforces a minimum total number of hours per scheduling week.\n\n**Example:**\n```ts\n{ name: "min-hours-week", hours: 30, priority: "HIGH" }\n```\n\n#### min-rest-between-shifts\nEnforces a minimum rest period between any two shifts a person works.\n\n**Example:**\n```ts\n{ name: "min-rest-between-shifts", hours: 10, priority: "MANDATORY" }\n```\n\n#### minimize-cost\nCreates the minimize-cost rule.\n\n**Hourly members:** adds a penalty proportional to\n`hourlyRate * shiftDurationMinutes / 60` for each assignment.\n\n**Salaried members:** zero marginal cost up to their contracted hours.\nA boolean variable tracks whether the member has any assignment in a\ngiven week. When active, their full weekly salary (`annual / 52`) is\nadded as a penalty. This causes the solver to load work onto salaried\nmembers (who are "free" once activated) before hourly workers.\n\n`costContext` so modifier rules can use the same scale.\n\n#### overtime-daily-multiplier\nCreates a daily overtime rate multiplier rule.\n\nSame as the weekly variant but the threshold is per day instead of per week.\n\n#### overtime-daily-surcharge\nCreates a daily overtime flat surcharge rule.\n\nHours beyond the threshold per day get a flat surcharge per hour,\nindependent of the member\'s base rate.\n\n#### overtime-tiered-multiplier\nCreates a multi-threshold weekly overtime multiplier rule.\n\nEach tier applies only to the hours between its threshold and the next.\nTiers are sorted by threshold ascending internally.\n\n**Example:**\n```typescript\n// Hours 0-40: base rate\n// Hours 40-48: 1.5x\n// Hours 48+: 2.0x\ntieredOvertimeMultiplier([\n  { after: 40, factor: 1.5 },\n  { after: 48, factor: 2.0 },\n])\n```\n\n#### overtime-weekly-multiplier\nCreates a weekly overtime rate multiplier rule.\n\nHours beyond the threshold per week are paid at `factor` times the base rate.\nThe base cost for all hours (including overtime at 1x) is already counted by\n`minimizeCost()`. This rule adds only the extra portion (`factor - 1`).\n\nAuxiliary variables and constraints are always emitted (they define the overtime\nstructure). The penalty terms both contribute to the objective and tighten the\novertime variables via minimization.\n\n#### overtime-weekly-surcharge\nCreates a weekly overtime flat surcharge rule.\n\nHours beyond the threshold per week get a flat surcharge per hour,\nindependent of the member\'s base rate.\n\n#### time-cost-surcharge\nCreates a time-of-day surcharge rule (e.g., night differential).\n\nAdds a flat surcharge per hour for the portion of a shift that overlaps\na time-of-day window. Independent of the member\'s base rate.\n\nWhen `minimizeCost()` is not present, no solver terms are emitted,\nbut the `cost()` method still contributes to post-solve calculation.\n\n#### time-off\nBlocks or penalizes assignments during specified time periods.\n\nSupports entity scoping (people, roles, skills) and time scoping\n(date ranges, specific dates, days of week, recurring periods).\nOptionally supports partial-day time-off with startTime/endTime.\n\n**Example:**\nFull day vacation\n```ts\n{ name: "time-off",\nmemberIds: ["alice"],\ndateRange: { start: "2024-02-01", end: "2024-02-05" },\npriority: "MANDATORY",\n}\n```\n\n**Example:**\nEvery Wednesday afternoon off for students\n```ts\n{ name: "time-off",\nroleIds: ["student"],\ndayOfWeek: ["wednesday"],\nstartTime: { hours: 14, minutes: 0 },\nendTime: { hours: 23, minutes: 59 },\npriority: "MANDATORY",\n}\n```\n\n**Example:**\nSpecific date, partial day\n```ts\n{ name: "time-off",\nmemberIds: ["bob"],\nspecificDates: ["2024-03-15"],\nstartTime: { hours: 16, minutes: 0 },\nendTime: { hours: 23, minutes: 59 },\npriority: "MANDATORY",\n}\n```\n\n---\n\n## Supporting Types\n\n### TimeOfDay\nTime of day representation (hours and minutes, with optional seconds/nanos).\n\nUsed for defining shift start/end times and semantic time boundaries.\nHours are in 24-hour format (0-23).\n\n**Example:**\n```typescript\nconst morningStart: TimeOfDay = {\n  hours: 9,\n  minutes: 0\n};\n\nconst afternoonEnd: TimeOfDay = {\n  hours: 17,\n  minutes: 30\n};\n```\n\n**Properties:**\n- `hours: number`\n- `minutes: number`\n- `seconds?: number | undefined`\n- `nanos?: number | undefined`\n\n\n### DayOfWeek\nDay of the week identifier.\n\n```typescript\n"monday" | "tuesday" | "wednesday" | "thursday" | "friday" | "saturday" | "sunday"\n```\n\n\n### SchedulingPeriod\nDefines a scheduling period as a date range with optional filters.\n\nThe `dateRange` specifies the overall scheduling window. Use `dayOfWeek`\nand/or `dates` to narrow which days within the range are included.\nFilters compose: a day must pass all specified filters to be included.\n\n**Example:**\nAll days in a week\n```typescript\nconst period: SchedulingPeriod = {\ndateRange: { start: \'2025-02-03\', end: \'2025-02-09\' },\n};\n```\n\n**Example:**\nOnly specific days of the week (restaurant closed Mon/Tue)\n```typescript\nconst period: SchedulingPeriod = {\ndateRange: { start: \'2025-02-03\', end: \'2025-02-09\' },\ndayOfWeek: [\'wednesday\', \'thursday\', \'friday\', \'saturday\', \'sunday\'],\n};\n```\n\n**Example:**\nOnly specific dates within the range\n```typescript\nconst period: SchedulingPeriod = {\ndateRange: { start: \'2025-02-03\', end: \'2025-02-09\' },\ndates: [\'2025-02-05\', \'2025-02-07\'],\n};\n```\n\n**Properties:**\n- `dateRange: { start: string; end: string; }` - The overall scheduling window (start and end are inclusive).\nDates should be in YYYY-MM-DD format.\n- `dayOfWeek?: DayOfWeek[] | undefined` - Include only these days of the week.\nIf omitted, all days of the week are included.\n- `dates?: string[] | undefined` - Include only these specific dates (YYYY-MM-DD) within the range.\nIf omitted, all dates in the range are included (subject to dayOfWeek filter).\n\n\n### HourlyPay\nPay per hour in the caller\'s smallest currency unit (e.g., pence, cents).\n\n**Properties:**\n- `hourlyRate: number` - Pay per hour in smallest currency unit.\n\n\n### SalariedPay\nAnnual salary with contracted weekly hours.\n\nThe solver treats salaried members as having a fixed weekly cost\n(`annual / 52`) that is incurred once they work any shift in a week.\nAdditional shifts within the same week have zero marginal cost.\n\nNote: overtime rules currently apply only to hourly members.\nSalaried members are skipped by overtime multiplier/surcharge rules.\n\n**Properties:**\n- `annual: number` - Annual salary in smallest currency unit.\n- `hoursPerWeek: number` - Contracted hours per week. Reserved for future overtime support.\n\n\n### Priority\nHow strictly the solver enforces a rule.\n\n- `"LOW"`, `"MEDIUM"`, `"HIGH"`: soft constraints with increasing penalty for violations\n- `"MANDATORY"`: hard constraint; the solver will not produce a solution that violates it\n\n```typescript\n"LOW" | "MEDIUM" | "HIGH" | "MANDATORY"\n```\n\n\n';
