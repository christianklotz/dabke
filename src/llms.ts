// Auto-generated — do not edit manually
export const apiDocs =
  '# dabke\n\n> Scheduling library powered by constraint programming (CP-SAT)\n\n---\n\n## Schedule Definition\n\n### `defineSchedule`\n\nDefine a complete schedule configuration.\n\n```typescript\nimport {\n  defineSchedule, t, time, cover, shift,\n  maxHoursPerWeek, minRestBetweenShifts, timeOff,\n  weekdays, weekend,\n} from "dabke";\n\nexport default defineSchedule({\n  roleIds: ["waiter", "runner", "manager"],\n  skillIds: ["senior"],\n\n  times: {\n    lunch: time({ startTime: t(12), endTime: t(15) }),\n    dinner: time(\n      { startTime: t(17), endTime: t(21) },\n      { startTime: t(18), endTime: t(22), dayOfWeek: weekend },\n    ),\n  },\n\n  coverage: [\n    cover("lunch", "waiter", 2),\n    cover("dinner", "waiter", 4, { dayOfWeek: weekdays }),\n    cover("dinner", "waiter", 6, { dayOfWeek: weekend }),\n  ],\n\n  shiftPatterns: [\n    shift("morning", t(11, 30), t(15)),\n    shift("evening", t(17), t(22)),\n  ],\n\n  rules: [\n    maxHoursPerWeek(48),\n    minRestBetweenShifts(10),\n    timeOff({ appliesTo: "alice", dayOfWeek: weekend }),\n  ],\n});\n```\n\n**Parameters:**\n- `config: ScheduleConfig<R, S, T>` — Schedule configuration object with:\n- `roleIds` (required): declared role names\n- `skillIds` (optional): declared skill names\n- `times` (required): named semantic time periods (see `time`)\n- `coverage` (required): staffing requirements (see `cover`)\n- `shiftPatterns` (required): available shifts (see `shift`)\n- `rules` (optional): constraints and preferences (see rule functions)\n- `dayOfWeek` (optional): days the business operates (inclusion filter)\n- `weekStartsOn` (optional): defaults to `"monday"`\n\n**Returns:** `ScheduleDefinition`\n\n---\n\n## Time Periods\n\n### `t`\n\nCreates a `TimeOfDay` value.\n\nHours only\n```ts\nt(9)   // { hours: 9, minutes: 0 }\n```\n\n**Parameters:**\n- `hours: number` — Hour component (0-23)\n- `minutes: number` — Minute component (0-59)\n\n**Returns:** `TimeOfDay`\n\n### `weekdays`\n\nMonday through Friday.\n\n```typescript\nreadonly DayOfWeek[]\n```\n\n### `weekend`\n\nSaturday and Sunday.\n\n```typescript\nreadonly DayOfWeek[]\n```\n\n### `time`\n\nDefine a named semantic time period.\n\nEach entry has `startTime`/`endTime` and optional `dayOfWeek` or `dates`\nscoping. Entries without scoping are the default.\n\n```typescript\ntimes: {\n  // Simple: same times every day\n  lunch: time({ startTime: t(12), endTime: t(15) }),\n\n  // Variants: different times on weekends\n  dinner: time(\n    { startTime: t(17), endTime: t(21) },\n    { startTime: t(18), endTime: t(22), dayOfWeek: weekend },\n  ),\n\n  // Point-in-time window (keyholder at opening)\n  opening: time({ startTime: t(8, 30), endTime: t(9) }),\n}\n```\n\n---\n\n## Coverage\n\n### `cover`\n\nDefines a staffing requirement for a semantic time period.\n\nEntries for the same time and role **stack additively**.\nFor weekday vs weekend staffing, use mutually exclusive `dayOfWeek`\non both entries.\n\n```typescript\ncoverage: [\n  // 2 waiters during lunch\n  cover("lunch", "waiter", 2),\n\n  // 1 manager OR supervisor during dinner\n  cover("dinner", ["manager", "supervisor"], 1),\n\n  // 1 person with keyholder skill at opening\n  cover("opening", "keyholder", 1),\n\n  // 1 senior waiter (role + skill AND)\n  cover("lunch", "waiter", 1, { skillIds: ["senior"] }),\n\n  // Different counts by day (mutually exclusive dayOfWeek!)\n  cover("lunch", "waiter", 2, { dayOfWeek: weekdays }),\n  cover("lunch", "waiter", 3, { dayOfWeek: weekend }),\n]\n```\n\n**Parameters:**\n- `timeName: T` — Name of a declared semantic time\n- `target: R | [R, ...R[]]` — Role name (string), array of role names (OR logic), or skill name\n- `count: number` — Number of people needed\n- `opts?: CoverageOptions` — Options: `skillIds` (AND filter), `dayOfWeek`, `dates`, `priority`\n\n**Returns:** `CoverageEntry<T, R>`\n\n---\n\n## Shift Patterns\n\n### `shift`\n\nDefine a shift pattern: a time slot available for employee assignment.\n\nEach pattern repeats daily unless filtered by `dayOfWeek`.\n\n```typescript\nshiftPatterns: [\n  shift("morning", t(11, 30), t(15)),\n  shift("evening", t(17), t(22)),\n\n  // Role-restricted shift\n  shift("kitchen", t(6), t(14), { roleIds: ["chef", "prep_cook"] }),\n\n  // Day-restricted shift\n  shift("saturday_short", t(9), t(14), { dayOfWeek: ["saturday"] }),\n\n  // Location-specific shift\n  shift("terrace_lunch", t(12), t(16), { locationId: "terrace" }),\n]\n```\n\n---\n\n## Rules\n\n### `RuleOptions`\n\nScoping options shared by most rule functions.\n\nDefault priority is `MANDATORY`. Use `appliesTo` to scope to a\nrole, skill, or member ID. Use time scoping options (`dayOfWeek`,\n`dateRange`, `dates`) to limit when the rule applies.\nNot all rules support all scoping options. Entity-only rules\n(e.g., `maxConsecutiveDays`) ignore time scoping.\n\n**Properties:**\n- `appliesTo?: string | string[]` — Who this rule applies to (role name, skill name, or member ID).\n- `dayOfWeek?: readonly DayOfWeek[]` — Restrict to specific days of the week.\n- `dateRange?: { start: string; end: string }` — Restrict to a date range.\n- `dates?: string[]` — Restrict to specific dates (YYYY-MM-DD).\n- `recurringPeriods?: [RecurringPeriod, ...RecurringPeriod[]]` — Restrict to recurring calendar periods.\n- `priority?: Priority` — Defaults to `"MANDATORY"`.\n\n### `maxHoursPerDay`\n\nLimits hours per day.\n\n```typescript\nmaxHoursPerDay(10)\nmaxHoursPerDay(4, { appliesTo: "student", dayOfWeek: weekdays })\n```\n\n### `maxHoursPerWeek`\n\nLimits hours per scheduling week.\n\n```typescript\nmaxHoursPerWeek(48)\nmaxHoursPerWeek(20, { appliesTo: "student" })\n```\n\n### `minHoursPerDay`\n\nMinimum hours when assigned on a day.\n\n```typescript\nminHoursPerDay(4)\n```\n\n### `minHoursPerWeek`\n\nMinimum hours per scheduling week.\n\n```typescript\nminHoursPerWeek(20, { priority: "HIGH" })\n```\n\n### `maxShiftsPerDay`\n\nMaximum distinct shifts per day.\n\n```typescript\nmaxShiftsPerDay(1)\nmaxShiftsPerDay(2, { appliesTo: "student", dayOfWeek: weekend })\n```\n\n### `maxConsecutiveDays`\n\nMaximum consecutive working days.\n\n```typescript\nmaxConsecutiveDays(5)\n```\n\n### `minConsecutiveDays`\n\nOnce working, continue for at least this many consecutive days.\n\n```typescript\nminConsecutiveDays(2, { priority: "HIGH" })\n```\n\n### `minRestBetweenShifts`\n\nMinimum rest hours between shifts.\n\n```typescript\nminRestBetweenShifts(10)\n```\n\n### `preference`\n\nPrefer (`"high"`) or avoid (`"low"`) assigning. Requires `appliesTo`.\n\n```typescript\npreference("high", { appliesTo: "waiter" })\npreference("low", { appliesTo: "student", dayOfWeek: weekdays })\n```\n\n### `preferLocation`\n\nPrefer assigning to shifts at a specific location. Requires `appliesTo`.\n\n```typescript\npreferLocation("terrace", { appliesTo: "alice" })\n```\n\n### `minimizeCost`\n\nTells the solver to minimize total labor cost.\n\nWithout this rule, cost modifiers only affect post-solve calculation.\nWhen present, the solver actively prefers cheaper assignments.\n\nFor hourly members, penalizes each assignment proportionally to cost.\nFor salaried members, adds a fixed weekly salary cost when they have\nany assignment that week (zero marginal cost up to contracted hours).\n\nCost modifiers adjust the calculation:\n- `dayMultiplier(factor, opts?)` - multiply base rate on specific days\n- `daySurcharge(amount, opts?)` - flat extra per hour on specific days\n- `timeSurcharge(amount, window, opts?)` - flat extra per hour during a time window\n- `overtimeMultiplier({ after, factor }, opts?)` - weekly overtime multiplier\n- `overtimeSurcharge({ after, amount }, opts?)` - weekly overtime surcharge\n- `dailyOvertimeMultiplier({ after, factor }, opts?)` - daily overtime multiplier\n- `dailyOvertimeSurcharge({ after, amount }, opts?)` - daily overtime surcharge\n- `tieredOvertimeMultiplier(tiers, opts?)` - multiple overtime thresholds\n\n```ts\nminimizeCost()\n```\n\n### `timeOff`\n\nBlock assignments during specified periods.\nRequires at least one time scope (`dayOfWeek`, `dateRange`, `dates`, or `from`/`until`).\n\n```typescript\n// Full days off\ntimeOff({ appliesTo: "alice", dateRange: { start: "2024-02-01", end: "2024-02-05" } })\n\n// Every weekend off\ntimeOff({ appliesTo: "mauro", dayOfWeek: weekend })\n\n// Wednesday afternoons off\ntimeOff({ appliesTo: "student", dayOfWeek: ["wednesday"], from: t(14) })\n```\n\n### `assignTogether`\n\nMembers work the same shifts on days they are both assigned.\n\n```typescript\nassignTogether(["alice", "bob"])\nassignTogether(["alice", "bob", "charlie"], { priority: "HIGH" })\n```\n\n---\n\n## Supporting Types\n\n### `DayOfWeek`\n\nDay of the week identifier.\n\n```typescript\n"monday" | "tuesday" | "wednesday" | "thursday" | "friday" | "saturday" | "sunday"\n```\n\n### `TimeOfDay`\n\nTime of day (24-hour format).\n\n**Properties:**\n- `hours: number`\n- `minutes: number`\n\n### `Priority`\n\nHow strictly the solver enforces a rule.\n\n- `"LOW"`, `"MEDIUM"`, `"HIGH"`: soft constraints with increasing penalty for violations\n- `"MANDATORY"`: hard constraint; the solver will not produce a solution that violates it\n\n```typescript\n"LOW" | "MEDIUM" | "HIGH" | "MANDATORY"\n```\n\n';
